import { useState, useEffect, useRef } from 'react'
import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } from 'react-leaflet'
import { Upload, MapPin, Filter, Ruler, X, Plus, Image as ImageIcon, Save, Trash2, Download, Share2, FolderPlus, Edit2, Menu, Search, Navigation, LogOut } from 'lucide-react'
import { Button } from '@/components/ui/button.jsx'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card.jsx'
import { Input } from '@/components/ui/input.jsx'
import { Label } from '@/components/ui/label.jsx'
import { Textarea } from '@/components/ui/textarea.jsx'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select.jsx'
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from '@/components/ui/sheet.jsx'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog.jsx'
import { supabase } from './lib/supabase'
import Auth from './components/Auth'
import JSZip from 'jszip'
import L from 'leaflet'
import { Network } from '@capacitor/network'
import { Preferences } from '@capacitor/preferences'
import './App.css'

// Fix para ícones do Leaflet
delete L.Icon.Default.prototype._getIconUrl
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
})

// Bairros padrão
const DEFAULT_BAIRROS = [
  'Ponta Verde',
  'Pajuçara',
  'Jatiúca',
  'Mangabeiras',
  'Farol',
  'Prado',
  'Centro',
  'Jaraguá',
  'Poço',
  'Levada'
]

// Componente para ajustar o mapa quando os marcadores mudam
function MapBounds({ markers }) {
  const map = useMap()
  
  useEffect(() => {
    if (markers.length > 0) {
      const bounds = L.latLngBounds(markers.map(m => [m.lat, m.lng]))
      map.fitBounds(bounds, { padding: [50, 50] })
    }
  }, [markers, map])
  
  return null
}

// Componente para rota animada
function AnimatedRoute({ routeCoordinates, onRouteComplete }) {
  const map = useMap()
  const polylineRef = useRef(null)
  
  useEffect(() => {
    if (!routeCoordinates || routeCoordinates.length === 0) {
      if (polylineRef.current) {
        map.removeLayer(polylineRef.current)
        polylineRef.current = null
      }
      return
    }

    // Remover polyline anterior se existir
    if (polylineRef.current) {
      map.removeLayer(polylineRef.current)
    }

    // Criar polyline animada
    let currentIndex = 0
    const animatedCoords = []
    
    const polyline = L.polyline([], {
      color: '#06B6D4',
      weight: 4,
      opacity: 0.8,
      smoothFactor: 1
    }).addTo(map)
    
    polylineRef.current = polyline

    // Animar o desenho da rota
    const animate = () => {
      if (currentIndex < routeCoordinates.length) {
        animatedCoords.push(routeCoordinates[currentIndex])
        polyline.setLatLngs(animatedCoords)
        currentIndex++
        setTimeout(animate, 10)
      } else {
        const bounds = L.latLngBounds(routeCoordinates)
        map.fitBounds(bounds, { padding: [50, 50] })
        if (onRouteComplete) onRouteComplete()
      }
    }
    
    animate()

    return () => {
      if (polylineRef.current) {
        map.removeLayer(polylineRef.current)
      }
    }
  }, [routeCoordinates, map, onRouteComplete])
  
  return null
}

function App() {
  const [user, setUser] = useState(null)
  const [authLoading, setAuthLoading] = useState(true)
  const [markers, setMarkers] = useState([])
  const [filteredMarkers, setFilteredMarkers] = useState([])
  const [selectedBairro, setSelectedBairro] = useState('todos')
  const [editingMarker, setEditingMarker] = useState(null)
  const [selectedForDistance, setSelectedForDistance] = useState([])
  const [distanceResult, setDistanceResult] = useState(null)
  const [uploading, setUploading] = useState(false)
  const [loading, setLoading] = useState(true)
  const [bairros, setBairros] = useState(DEFAULT_BAIRROS)
  const [showAddBairro, setShowAddBairro] = useState(false)
  const [newBairro, setNewBairro] = useState('')
  const [routeCoordinates, setRouteCoordinates] = useState([])
  const [calculatingRoute, setCalculatingRoute] = useState(false)
  const [isOnline, setIsOnline] = useState(true)
  const [syncPending, setSyncPending] = useState(false)
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [showEditDialog, setShowEditDialog] = useState(false)
  const [showAddMarkerDialog, setShowAddMarkerDialog] = useState(false)
  const [newMarkerData, setNewMarkerData] = useState({ name: '', lat: '', lng: '', bairro: '', descricao: '' })
  const [showRouteDialog, setShowRouteDialog] = useState(false)
  const [selectedMarkersForRoute, setSelectedMarkersForRoute] = useState([])

  // Verificar autenticação ao iniciar
  useEffect(() => {
    const checkAuth = async () => {
      const { data: { session } } = await supabase.auth.getSession()
      setUser(session?.user ?? null)
      setAuthLoading(false)
    }
    checkAuth()

    // Listener para mudanças de autenticação
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
    })

    return () => subscription.unsubscribe()
  }, [])

  // Função de logout
  const handleLogout = async () => {
    await supabase.auth.signOut()
    setMarkers([])
    setFilteredMarkers([])
  }

  // Carregar bairros personalizados do localStorage
  useEffect(() => {
    const savedBairros = localStorage.getItem('jamaaw_bairros')
    if (savedBairros) {
      setBairros(JSON.parse(savedBairros))
    }
  }, [])

  // Salvar bairros personalizados no localStorage
  const saveBairros = (newBairros) => {
    setBairros(newBairros)
    localStorage.setItem('jamaaw_bairros', JSON.stringify(newBairros))
  }

  // Adicionar novo bairro
  const handleAddBairro = () => {
    if (newBairro.trim() && !bairros.includes(newBairro.trim())) {
      const updatedBairros = [...bairros, newBairro.trim()]
      saveBairros(updatedBairros)
      setNewBairro('')
      setShowAddBairro(false)
    }
  }

  // Remover bairro
  const handleRemoveBairro = (bairro) => {
    if (DEFAULT_BAIRROS.includes(bairro)) {
      alert('Não é possível remover bairros padrão.')
      return
    }
    if (confirm(`Deseja remover o bairro "${bairro}"?`)) {
      const updatedBairros = bairros.filter(b => b !== bairro)
      saveBairros(updatedBairros)
      if (selectedBairro === bairro) {
        setSelectedBairro('todos')
      }
    }
  }

  // Monitorar conectividade
  useEffect(() => {
    const checkConnectivity = async () => {
      try {
        const status = await Network.getStatus()
        setIsOnline(status.connected)
      } catch (error) {
        // Se falhar (web), assumir online
        setIsOnline(true)
      }
    }

    checkConnectivity()

    // Listener para mudanças de conectividade
    let networkListener
    const setupListener = async () => {
      try {
        networkListener = await Network.addListener('networkStatusChange', status => {
          setIsOnline(status.connected)
          if (status.connected && syncPending) {
            loadMarkers()
            setSyncPending(false)
          }
        })
      } catch (error) {
        // Se falhar (web), não fazer nada
      }
    }

    setupListener()

    return () => {
      if (networkListener) {
        networkListener.remove()
      }
    }
  }, [syncPending])

  // Carregar marcações do Supabase ao iniciar
  useEffect(() => {
    if (user) {
      loadMarkers()
    }
  }, [user])

  // Função para carregar marcações do Supabase ou cache local
  const loadMarkers = async () => {
    if (!user) return
    
    try {
      setLoading(true)
      
      // Tentar carregar do Supabase se estiver online
      if (isOnline) {
        const { data, error } = await supabase
          .from('marcacoes')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })

        if (error) {
          if (error.code === '42P01') {
            console.log('Tabela não existe, será criada no primeiro upload')
          } else {
            console.error('Erro ao carregar marcações:', error)
            await loadMarkersFromCache()
          }
        } else {
          setMarkers(data || [])
          // Salvar no cache local para uso offline
          try {
            await Preferences.set({
              key: `jamaaw_markers_${user.id}`,
              value: JSON.stringify(data || [])
            })
          } catch (e) {
            // Se falhar (web), usar localStorage
            localStorage.setItem(`jamaaw_markers_${user.id}`, JSON.stringify(data || []))
          }
        }
      } else {
        await loadMarkersFromCache()
      }
    } catch (error) {
      console.error('Erro ao carregar marcações:', error)
      await loadMarkersFromCache()
    } finally {
      setLoading(false)
    }
  }

  // Função para carregar marcações do cache local
  const loadMarkersFromCache = async () => {
    if (!user) return
    
    try {
      let cachedMarkers = null
      try {
        const { value } = await Preferences.get({ key: `jamaaw_markers_${user.id}` })
        if (value) {
          cachedMarkers = JSON.parse(value)
        }
      } catch (e) {
        // Se falhar (web), tentar localStorage
        const value = localStorage.getItem(`jamaaw_markers_${user.id}`)
        if (value) {
          cachedMarkers = JSON.parse(value)
        }
      }
      
      if (cachedMarkers) {
        setMarkers(cachedMarkers)
        console.log('Marcações carregadas do cache local')
      }
    } catch (error) {
      console.error('Erro ao carregar marcações do cache:', error)
    }
  }

  // Função para salvar marcação no Supabase
  const saveMarkerToSupabase = async (marker) => {
    if (!user) return null
    
    try {
      const { data, error } = await supabase
        .from('marcacoes')
        .insert([{
          user_id: user.id,
          name: marker.name,
          lat: marker.lat,
          lng: marker.lng,
          bairro: marker.bairro || null,
          rua: marker.rua || null,
          descricao: marker.descricao || null,
          fotos: marker.fotos || []
        }])
        .select()

      if (error) throw error
      return data[0]
    } catch (error) {
      console.error('Erro ao salvar marcação:', error)
      throw error
    }
  }

  // Função para atualizar marcação no Supabase
  const updateMarkerInSupabase = async (marker) => {
    try {
      const { data, error } = await supabase
        .from('marcacoes')
        .update({
          name: marker.name,
          bairro: marker.bairro || null,
          rua: marker.rua || null,
          descricao: marker.descricao || null,
          fotos: marker.fotos || [],
          updated_at: new Date().toISOString()
        })
        .eq('id', marker.id)
        .select()

      if (error) throw error
      return data[0]
    } catch (error) {
      console.error('Erro ao atualizar marcação:', error)
      throw error
    }
  }

  // Função para deletar marcação do Supabase
  const deleteMarkerFromSupabase = async (markerId) => {
    try {
      const { error } = await supabase
        .from('marcacoes')
        .delete()
        .eq('id', markerId)

      if (error) throw error
    } catch (error) {
      console.error('Erro ao deletar marcação:', error)
      throw error
    }
  }

  // Filtrar marcadores por bairro
  useEffect(() => {
    try {
      if (selectedBairro === 'todos') {
        setFilteredMarkers([...markers])
      } else {
        setFilteredMarkers(markers.filter(m => m.bairro === selectedBairro))
      }
    } catch (error) {
      console.error('Erro ao filtrar marcadores:', error)
      setFilteredMarkers([])
    }
  }, [markers, selectedBairro])

  // Função para obter rota usando OSRM API pública
  const getRouteFromAPI = async (start, end) => {
    try {
      const response = await fetch(
        `https://router.project-osrm.org/route/v1/foot/${start[0]},${start[1]};${end[0]},${end[1]}?overview=full&geometries=geojson`,
        {
          headers: {
            'Accept': 'application/json'
          }
        }
      )

      if (!response.ok) {
        throw new Error('Erro na API de roteamento')
      }

      const data = await response.json()
      
      if (data.routes && data.routes[0] && data.routes[0].geometry) {
        const coordinates = data.routes[0].geometry.coordinates
        return coordinates.map(coord => [coord[1], coord[0]])
      }
      
      return null
    } catch (error) {
      console.error('Erro ao buscar rota:', error)
      return null
    }
  }

  // Função para calcular distância usando OSRM Table API
  const calculateDistanceMatrix = async (coordinates) => {
    try {
      const coordsString = coordinates.map(c => `${c[0]},${c[1]}`).join(';')
      const response = await fetch(
        `https://router.project-osrm.org/table/v1/foot/${coordsString}?annotations=distance`,
        {
          headers: {
            'Accept': 'application/json'
          }
        }
      )

      if (!response.ok) {
        throw new Error('Erro na API de Distance Matrix')
      }

      const data = await response.json()
      return data.distances
    } catch (error) {
      console.error('Erro ao calcular distância via API:', error)
      return null
    }
  }

  // Função para calcular distância entre dois pontos (Haversine - fallback)
  const calculateDistance = (lat1, lng1, lat2, lng2) => {
    const R = 6371e3
    const φ1 = lat1 * Math.PI / 180
    const φ2 = lat2 * Math.PI / 180
    const Δφ = (lat2 - lat1) * Math.PI / 180
    const Δλ = (lng2 - lng1) * Math.PI / 180

    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ / 2) * Math.sin(Δλ / 2)
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

    return R * c
  }

  // Função para importar arquivo KML/KMZ
  const handleFileImport = async (event) => {
    const file = event.target.files[0]
    if (!file) return

    setUploading(true)
    try {
      let kmlText

      if (file.name.endsWith('.kmz')) {
        const zip = new JSZip()
        const contents = await zip.loadAsync(file)
        const kmlFile = Object.keys(contents.files).find(name => name.endsWith('.kml'))
        if (!kmlFile) {
          throw new Error('Arquivo KML não encontrado no KMZ')
        }
        kmlText = await contents.files[kmlFile].async('string')
      } else {
        kmlText = await file.text()
      }

      const parser = new DOMParser()
      const xmlDoc = parser.parseFromString(kmlText, 'text/xml')
      const placemarks = xmlDoc.getElementsByTagName('Placemark')

      const newMarkers = []
      for (let placemark of placemarks) {
        const name = placemark.getElementsByTagName('name')[0]?.textContent || 'Sem nome'
        const coordinates = placemark.getElementsByTagName('coordinates')[0]?.textContent.trim()
        
        if (coordinates) {
          const [lng, lat] = coordinates.split(',').map(Number)
          
          const marker = {
            name,
            lat,
            lng,
            bairro: null,
            rua: null,
            descricao: null,
            fotos: []
          }

          // Geocoding reverso para obter nome da rua
          try {
            const response = await fetch(
              `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`,
              {
                headers: {
                  'User-Agent': 'JamaawMap/1.0'
                }
              }
            )
            const data = await response.json()
            if (data.address) {
              marker.rua = data.address.road || data.address.street || data.display_name
            }
          } catch (error) {
            console.error('Erro ao obter nome da rua:', error)
          }

          // Salvar no Supabase
          const savedMarker = await saveMarkerToSupabase(marker)
          newMarkers.push(savedMarker)
        }
      }

      setMarkers(newMarkers)
      // Opcional: Se quiser manter as marcações antigas e adicionar as novas, use a linha acima.
      // Para remover as antigas e usar apenas as novas do KMZ, use:
      // setMarkers(newMarkers)

      alert(`${newMarkers.length} marcações importadas com sucesso!`)
    } catch (error) {
      console.error('Erro ao importar arquivo:', error)
      alert('Erro ao importar arquivo. Verifique o formato.')
    } finally {
      setUploading(false)
    }
  }

  // Função para exportar marcações como KML
  const handleExport = () => {
    const markersToExport = selectedBairro === 'todos' ? markers : filteredMarkers

    let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n  <Document>\n    <name>Jamaaw Map - ${selectedBairro === 'todos' ? 'Todas as Marcações' : selectedBairro}</name>\n`

    markersToExport.forEach(marker => {
      kmlContent += `    <Placemark>\n      <name>${marker.name}</name>\n      ${marker.descricao ? `<description>${marker.descricao}</description>` : ''}\n      <Point>\n        <coordinates>${marker.lng},${marker.lat},0</coordinates>\n      </Point>\n    </Placemark>\n`
    })

    kmlContent += `  </Document>\n</kml>`

    const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `jamaaw-map-${selectedBairro}-${new Date().toISOString().split('T')[0]}.kml`
    a.click()
    URL.revokeObjectURL(url)
  }

  // Função para adicionar nova marcação manualmente
  const handleAddMarker = async () => {
    if (!newMarkerData.name || !newMarkerData.lat || !newMarkerData.lng) {
      alert('Preencha pelo menos o nome e as coordenadas')
      return
    }

    try {
      const marker = {
        name: newMarkerData.name,
        lat: parseFloat(newMarkerData.lat),
        lng: parseFloat(newMarkerData.lng),
        bairro: newMarkerData.bairro || null,
        rua: null,
        descricao: newMarkerData.descricao || null,
        fotos: []
      }

      // Geocoding reverso para obter nome da rua
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${marker.lat}&lon=${marker.lng}`,
          {
            headers: {
              'User-Agent': 'JamaawMap/1.0'
            }
          }
        )
        const data = await response.json()
        if (data.address) {
          marker.rua = data.address.road || data.address.street || data.display_name
        }
      } catch (error) {
        console.error('Erro ao obter nome da rua:', error)
      }

      const savedMarker = await saveMarkerToSupabase(marker)
      setMarkers(prev => [savedMarker, ...prev])
      setNewMarkerData({ name: '', lat: '', lng: '', bairro: '', descricao: '' })
      setShowAddMarkerDialog(false)
      alert('Marcação adicionada com sucesso!')
    } catch (error) {
      console.error('Erro ao adicionar marcação:', error)
      alert('Erro ao adicionar marcação')
    }
  }

  // Função para editar marcação
  const handleEditMarker = (marker) => {
    setEditingMarker({ ...marker })
    setShowEditDialog(true)
  }

  // Função para salvar edição de marcação
  const handleSaveEdit = async () => {
    try {
      const updatedMarker = await updateMarkerInSupabase(editingMarker)
      setMarkers(prev => prev.map(m => m.id === updatedMarker.id ? updatedMarker : m))
      setShowEditDialog(false)
      setEditingMarker(null)
      alert('Marcação atualizada com sucesso!')
    } catch (error) {
      console.error('Erro ao salvar edição:', error)
      alert('Erro ao salvar edição')
    }
  }

  // Função para deletar marcação
  const handleDeleteMarker = async () => {
    if (!confirm('Deseja realmente deletar esta marcação?')) return

    try {
      await deleteMarkerFromSupabase(editingMarker.id)
      setMarkers(prev => prev.filter(m => m.id !== editingMarker.id))
      setShowEditDialog(false)
      setEditingMarker(null)
      alert('Marcação deletada com sucesso!')
    } catch (error) {
      console.error('Erro ao deletar marcação:', error)
      alert('Erro ao deletar marcação')
    }
  }

  // Função para fazer upload de fotos
  const handlePhotoUpload = async (event) => {
    const files = Array.from(event.target.files)
    if (files.length === 0) return

    try {
      const uploadedUrls = []
      
      for (const file of files) {
        const fileName = `${Date.now()}-${file.name}`
        const { data, error } = await supabase.storage
          .from('kmz-files')
          .upload(fileName, file)

        if (error) throw error

        const { data: { publicUrl } } = supabase.storage
          .from('kmz-files')
          .getPublicUrl(fileName)

        uploadedUrls.push(publicUrl)
      }

      setEditingMarker(prev => ({
        ...prev,
        fotos: [...(prev.fotos || []), ...uploadedUrls]
      }))
    } catch (error) {
      console.error('Erro ao fazer upload de fotos:', error)
      alert('Erro ao fazer upload de fotos')
    }
  }

  // Função para calcular distância entre marcadores selecionados
  const handleCalculateDistance = async () => {
    if (selectedForDistance.length === 2) {
      setCalculatingRoute(true)
      const [m1, m2] = selectedForDistance
      
      const route = await getRouteFromAPI([m1.lng, m1.lat], [m2.lng, m2.lat])
      
      if (route) {
        setRouteCoordinates(route)
        
        const coordinates = [
          [m1.lng, m1.lat],
          [m2.lng, m2.lat]
        ]
        
        const distanceMatrix = await calculateDistanceMatrix(coordinates)
        let distance

        if (distanceMatrix && distanceMatrix[0] && distanceMatrix[0][1]) {
          distance = distanceMatrix[0][1]
        } else {
          distance = calculateDistance(m1.lat, m1.lng, m2.lat, m2.lng)
        }

        setDistanceResult({
          type: 'dois',
          distance: distance.toFixed(2),
          markers: [m1.name, m2.name],
          method: 'rota'
        })
      } else {
        const distance = calculateDistance(m1.lat, m1.lng, m2.lat, m2.lng)
        setRouteCoordinates([[m1.lat, m1.lng], [m2.lat, m2.lng]])
        
        setDistanceResult({
          type: 'dois',
          distance: distance.toFixed(2),
          markers: [m1.name, m2.name],
          method: 'linha reta'
        })
      }
      
      setCalculatingRoute(false)
    } else {
      alert('Selecione exatamente 2 marcadores para calcular a distância.')
    }
  }

  // Função para limpar rota do mapa
  const handleClearRoute = () => {
    setRouteCoordinates([])
    setDistanceResult(null)
    setSelectedForDistance([])
  }

  // Função para calcular distância total entre todas as marcações
  const handleCalculateAllDistances = () => {
    const markersToCalculate = selectedBairro === 'todos' ? markers : filteredMarkers
    
    if (markersToCalculate.length < 2) {
      alert('É necessário ter pelo menos 2 marcações.')
      return
    }

    let totalDistance = 0
    for (let i = 0; i < markersToCalculate.length - 1; i++) {
      for (let j = i + 1; j < markersToCalculate.length; j++) {
        const m1 = markersToCalculate[i]
        const m2 = markersToCalculate[j]
        totalDistance += calculateDistance(m1.lat, m1.lng, m2.lat, m2.lng)
      }
    }

    setDistanceResult({
      type: 'todas',
      distance: totalDistance.toFixed(2),
      count: markersToCalculate.length,
      method: 'linha reta'
    })
  }

  // Função para compartilhar localização
  const handleShareLocation = (marker) => {
    const url = `https://www.google.com/maps?q=${marker.lat},${marker.lng}`
    
    if (navigator.share) {
      navigator.share({
        title: marker.name,
        text: `Confira esta localização: ${marker.name}`,
        url: url
      }).catch(err => console.log('Erro ao compartilhar:', err))
    } else {
      navigator.clipboard.writeText(url)
      alert('Link copiado para a área de transferência!')
    }
  }

  // Função para selecionar marcador para cálculo de distância
  const toggleMarkerSelection = (marker) => {
    if (selectedForDistance.find(m => m.id === marker.id)) {
      setSelectedForDistance(prev => prev.filter(m => m.id !== marker.id))
    } else {
      if (selectedForDistance.length < 2) {
        setSelectedForDistance(prev => [...prev, marker])
      } else {
        alert('Você já selecionou 2 marcadores. Limpe a seleção para escolher outros.')
      }
    }
  }

  // Função para obter contagem de marcadores por bairro
  const getMarkerCountByBairro = (bairro) => {
    if (bairro === 'todos') return markers.length
    return markers.filter(m => m.bairro === bairro).length
  }

  // Renderizar tela de autenticação se não estiver logado
  if (authLoading) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-900">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-cyan-500"></div>
      </div>
    )
  }

  if (!user) {
    return <Auth onAuthSuccess={(user) => setUser(user)} />
  }

  return (
    <div className="relative h-screen w-screen overflow-hidden bg-slate-900">
      {/* Mapa em tela cheia */}
      <div className="absolute inset-0 z-0">
        <MapContainer
          center={[-9.6658, -35.7353]}
          zoom={13}
          className="h-full w-full"
          zoomControl={false}
        >
          <TileLayer
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>'
            url="https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
            subdomains="abcd"
            maxZoom={20}
          />
          {filteredMarkers.map(marker => (
            <Marker
              key={marker.id}
              position={[marker.lat, marker.lng]}
              eventHandlers={{
                click: () => handleEditMarker(marker)
              }}
            >
              <Popup>
                <div className="text-sm">
                  <h3 className="font-semibold text-slate-900">{marker.name}</h3>
                  {marker.bairro && <p className="text-xs text-gray-600">{marker.bairro}</p>}
                  {marker.rua && <p className="text-xs text-gray-600">{marker.rua}</p>}
                  <Button
                    size="sm"
                    variant="outline"
                    className="mt-2 w-full"
                    onClick={() => handleShareLocation(marker)}
                  >
                    <Share2 className="w-3 h-3 mr-1" />
                    Compartilhar
                  </Button>
                </div>
              </Popup>
            </Marker>
          ))}
          <AnimatedRoute routeCoordinates={routeCoordinates} />
          <MapBounds markers={filteredMarkers} />
        </MapContainer>
      </div>

      {/* Barra de ferramentas flutuante no topo */}
      <div className="absolute top-4 left-4 right-4 z-10 flex items-center gap-2">
        {/* Menu hambúrguer */}
        <Sheet open={sidebarOpen} onOpenChange={setSidebarOpen}>
          <SheetTrigger asChild>
            <Button
              size="icon"
              className="bg-slate-800/90 backdrop-blur-sm hover:bg-slate-700 text-white shadow-lg"
            >
              <Menu className="w-5 h-5" />
            </Button>
          </SheetTrigger>
          <SheetContent side="left" className="w-80 bg-slate-900 text-white border-slate-700">
            <SheetHeader>
              <SheetTitle className="flex items-center gap-2 text-white">
                <img src="/jamaaw-logo.jpg" alt="Jamaaw" className="w-8 h-8 rounded" />
                Mapa Jamaaw
              </SheetTitle>
            </SheetHeader>
            
            <div className="mt-6 space-y-4">
              {/* Filtros de Bairro */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <h3 className="text-sm font-semibold text-cyan-400">Filtrar por Bairro</h3>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => setShowAddBairro(!showAddBairro)}
                    className="h-7 text-cyan-400 hover:text-cyan-300"
                  >
                    <Plus className="w-4 h-4" />
                  </Button>
                </div>

                {showAddBairro && (
                  <div className="flex gap-2 mb-3">
                    <Input
                      value={newBairro}
                      onChange={(e) => setNewBairro(e.target.value)}
                      placeholder="Novo bairro"
                      className="h-8 text-sm bg-slate-800 border-slate-700 text-white"
                      onKeyPress={(e) => e.key === 'Enter' && handleAddBairro()}
                    />
                    <Button
                      size="sm"
                      onClick={handleAddBairro}
                      className="h-8 bg-cyan-500 hover:bg-cyan-600"
                    >
                      <Plus className="w-3 h-3" />
                    </Button>
                  </div>
                )}

                <div className="space-y-1 max-h-64 overflow-y-auto">
                  <Button
                    variant={selectedBairro === 'todos' ? 'default' : 'ghost'}
                    className={`w-full justify-between text-left ${
                      selectedBairro === 'todos'
                        ? 'bg-cyan-500 hover:bg-cyan-600'
                        : 'hover:bg-slate-800'
                    }`}
                    onClick={() => {
                      setSelectedBairro('todos')
                      setSidebarOpen(false)
                    }}
                  >
                    <span>Todos</span>
                    <span className="text-xs">({getMarkerCountByBairro('todos')})</span>
                  </Button>
                  
                  {bairros.map(bairro => (
                    <div key={bairro} className="relative group">
                      <Button
                        variant={selectedBairro === bairro ? 'default' : 'ghost'}
                        className={`w-full justify-between text-left ${
                          selectedBairro === bairro
                            ? 'bg-cyan-500 hover:bg-cyan-600'
                            : 'hover:bg-slate-800'
                        }`}
                        onClick={() => {
                          setSelectedBairro(bairro)
                          setSidebarOpen(false)
                        }}
                      >
                        <span>{bairro}</span>
                        <span className="text-xs">({getMarkerCountByBairro(bairro)})</span>
                      </Button>
                      {!DEFAULT_BAIRROS.includes(bairro) && (
                        <Button
                          size="sm"
                          variant="ghost"
                          className="absolute right-1 top-1 h-6 w-6 p-0 opacity-0 group-hover:opacity-100 hover:bg-red-500/20 hover:text-red-400"
                          onClick={(e) => {
                            e.stopPropagation()
                            handleRemoveBairro(bairro)
                          }}
                        >
                          <X className="w-3 h-3" />
                        </Button>
                      )}
                    </div>
                  ))}
                </div>
              </div>

              {/* Informações do Usuário */}
              <div className="pt-4 border-t border-slate-700">
                <div className="flex items-center justify-between p-3 bg-slate-800/50 rounded-lg">
                  <div className="flex-1 min-w-0">
                    <p className="text-xs text-gray-400">Logado como:</p>
                    <p className="text-sm text-white truncate">{user?.email}</p>
                  </div>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={handleLogout}
                    className="text-red-400 hover:text-red-300 hover:bg-red-500/20"
                  >
                    <LogOut className="w-4 h-4" />
                  </Button>
                </div>
              </div>

              {/* Ações */}
              <div className="pt-4 border-t border-slate-700 space-y-2">
                <Button
                  className="w-full justify-start bg-cyan-500 hover:bg-cyan-600"
                  onClick={() => document.getElementById('file-input').click()}
                  disabled={uploading}
                >
                  <Upload className="w-4 h-4 mr-2" />
                  {uploading ? 'Importando...' : 'Importar KML/KMZ'}
                </Button>
                
                <Button
                  className="w-full justify-start bg-blue-500 hover:bg-blue-600"
                  onClick={handleExport}
                  disabled={markers.length === 0}
                >
                  <Download className="w-4 h-4 mr-2" />
                  Exportar KML
                </Button>

                <Button
                  className="w-full justify-start bg-purple-500 hover:bg-purple-600"
                  onClick={handleCalculateDistance}
                  disabled={selectedForDistance.length !== 2}
                >
                  <Ruler className="w-4 h-4 mr-2" />
                  Calcular Rota (2 Postes)
                </Button>

                <Button
                  className="w-full justify-start bg-indigo-500 hover:bg-indigo-600"
                  onClick={handleCalculateAllDistances}
                  disabled={markers.length < 2}
                >
                  <Ruler className="w-4 h-4 mr-2" />
                  Calcular Todas
                </Button>

                {routeCoordinates.length > 0 && (
                  <Button
                    className="w-full justify-start bg-red-500 hover:bg-red-600"
                    onClick={handleClearRoute}
                  >
                    <X className="w-4 h-4 mr-2" />
                    Cancelar
                  </Button>
                )}
              </div>

              {/* Lista de Marcações */}
              <div className="pt-4 border-t border-slate-700">
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-semibold text-cyan-400">
                    Marcações
                  </h3>
                  {selectedForDistance.length > 0 && (
                    <div className="flex items-center gap-2">
                      <span className="text-xs text-cyan-400 bg-cyan-500/20 px-2 py-1 rounded">
                        {selectedForDistance.length} selecionados
                      </span>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => setSelectedForDistance([])}
                        className="h-6 text-xs text-red-400 hover:text-red-300 hover:bg-red-500/20"
                      >
                        Limpar
                      </Button>
                    </div>
                  )}
                </div>
                <div className="space-y-2 max-h-64 overflow-y-auto pr-2 custom-scrollbar">
                  {filteredMarkers.map(marker => {
                    const isSelected = selectedForDistance.find(m => m.id === marker.id)
                    return (
                      <div
                        key={marker.id}
                        className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all-smooth hover-lift ${
                          isSelected
                            ? 'bg-cyan-600/30 border-2 border-cyan-500 selected-item'
                            : 'bg-slate-800/50 hover:bg-slate-800 border-2 border-transparent'
                        }`}
                        onClick={(e) => {
                          // Only toggle selection if the click is not on the edit button
                          if (!e.target.closest("button") || (e.target.closest("button") && !e.target.closest("button").id.startsWith('edit-marker-'))) {
                            toggleMarkerSelection(marker)
                          }
                        }}
                      >
                        <div className="flex items-center justify-center w-6 h-6 flex-shrink-0">
                          <input
                            type="checkbox"
                            checked={!!isSelected}
                            readOnly
                            className="w-5 h-5 rounded border-2 border-slate-600 bg-slate-700 checked:bg-cyan-500 checked:border-cyan-500 cursor-pointer"
                            style={{ accentColor: '#06B6D4' }}
                          />
                        </div>
                        <div className="flex-1 min-w-0">
                          <button
                            className="text-left text-sm font-medium truncate hover:text-cyan-400 w-full"
                            onClick={(e) => {
                              e.stopPropagation()
                              handleEditMarker(marker)
                              setSidebarOpen(false)
                            }}
                          >
                            {marker.name}
                          </button>
                          {marker.bairro && (
                            <p className="text-xs text-gray-400 truncate">{marker.bairro}</p>
                          )}
                        </div>
                          <Button
                            id={`edit-marker-${marker.id}`}
                            size="sm"
                            variant="ghost"
                            className="h-8 w-8 p-0 flex-shrink-0 hover:bg-slate-700"
                            onClick={(e) => {
                              e.stopPropagation()
                              handleEditMarker(marker)
                              setSidebarOpen(false)
                            }}
                          >
                          <Edit2 className="w-4 h-4 text-gray-400" />
                        </Button>
                      </div>
                    )
                  })}
                </div>
              </div>
            </div>
          </SheetContent>
        </Sheet>

        {/* Logo e título */}
        <div className="flex-1 flex items-center gap-2 bg-slate-800/90 backdrop-blur-sm rounded-lg px-4 py-2 shadow-lg">
          <img src="/jamaaw-logo.jpg" alt="Jamaaw" className="w-8 h-8 rounded" />
          <span className="font-semibold text-white hidden sm:inline">Mapa Jamaaw</span>
          {!isOnline && (
            <span className="text-xs text-orange-400 ml-2">Offline</span>
          )}
        </div>
      </div>

      {/* Botões flutuantes */}
      <div className="absolute bottom-24 right-4 z-10 flex flex-col gap-3">
        <Button
          size="icon"
          className="w-14 h-14 rounded-full bg-emerald-500 hover:bg-emerald-600 shadow-lg"
          onClick={() => setShowRouteDialog(true)}
        >
          <Navigation className="w-6 h-6" />
        </Button>
        <Button
          size="icon"
          className="w-14 h-14 rounded-full bg-cyan-500 hover:bg-cyan-600 shadow-lg"
          onClick={() => setShowAddMarkerDialog(true)}
        >
          <Plus className="w-6 h-6" />
        </Button>
      </div>

      {/* Resultado de distância flutuante */}
      {distanceResult && (
        <div className="absolute bottom-4 left-4 right-4 z-10 bg-slate-800/95 backdrop-blur-sm rounded-lg p-4 shadow-lg text-white">
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <h3 className="font-semibold text-cyan-400 mb-1">
                {distanceResult.type === 'dois' ? 'Distância entre 2 Postes' : 'Distância Total'}
              </h3>
              <p className="text-2xl font-bold">{distanceResult.distance} m</p>
              {distanceResult.type === 'dois' && (
                <p className="text-sm text-gray-400 mt-1">
                  {distanceResult.markers[0]} → {distanceResult.markers[1]}
                </p>
              )}
              {distanceResult.type === 'todas' && (
                <p className="text-sm text-gray-400 mt-1">
                  {distanceResult.count} marcações
                </p>
              )}
              <p className="text-xs text-gray-500 mt-1">
                Método: {distanceResult.method}
              </p>
            </div>
            <Button
              size="sm"
              variant="ghost"
              onClick={handleClearRoute}
              className="text-gray-400 hover:text-white"
            >
              <X className="w-4 h-4" />
            </Button>
          </div>
        </div>
      )}

      {/* Loading overlay */}
      {calculatingRoute && (
        <div className="absolute top-20 left-1/2 -translate-x-1/2 bg-slate-800/95 backdrop-blur-sm px-4 py-2 rounded-lg shadow-lg z-10 flex items-center gap-2 text-white">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-cyan-500"></div>
          <span className="text-sm font-medium">Calculando rota...</span>
        </div>
      )}

      {/* Dialog de edição de marcação */}
      <Dialog open={showEditDialog} onOpenChange={(open) => {
        setShowEditDialog(open)
        if (!open) {
          setEditingMarker(null)
        }
      }}>
        <DialogContent className="bg-slate-900 text-white border-slate-700 max-w-md">
          <DialogHeader>
            <DialogTitle className="text-cyan-400">Editar Marcação</DialogTitle>
          </DialogHeader>
          {editingMarker && (
            <div className="space-y-4">
              <div>
                <Label className="text-gray-300">Nome</Label>
                <Input
                  value={editingMarker.name}
                  onChange={(e) => setEditingMarker({ ...editingMarker, name: e.target.value })}
                  className="bg-slate-800 border-slate-700 text-white"
                />
              </div>
              <div>
                <Label className="text-gray-300">Bairro</Label>
                <Select
                  value={editingMarker.bairro || ''}
                  onValueChange={(value) => setEditingMarker({ ...editingMarker, bairro: value })}
                >
                  <SelectTrigger className="bg-slate-800 border-slate-700 text-white">
                    <SelectValue placeholder="Selecione um bairro" />
                  </SelectTrigger>
                  <SelectContent className="bg-slate-800 border-slate-700 text-white z-[9999]">
                    {bairros.map(bairro => (
                      <SelectItem key={bairro} value={bairro}>{bairro}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div>
                <Label className="text-gray-300">Rua</Label>
                <Input
                  value={editingMarker.rua || ''}
                  onChange={(e) => setEditingMarker({ ...editingMarker, rua: e.target.value })}
                  className="bg-slate-800 border-slate-700 text-white"
                  placeholder="Nome da rua"
                />
              </div>
              <div>
                <Label className="text-gray-300">Descrição</Label>
                <Textarea
                  value={editingMarker.descricao || ''}
                  onChange={(e) => setEditingMarker({ ...editingMarker, descricao: e.target.value })}
                  className="bg-slate-800 border-slate-700 text-white"
                  rows={3}
                />
              </div>
              <div>
                <Label className="text-gray-300">Fotos</Label>
                <div className="flex flex-wrap gap-2 mt-2">
                  {editingMarker.fotos?.map((foto, index) => (
                    <img key={index} src={foto} alt={`Foto ${index + 1}`} className="w-20 h-20 object-cover rounded" />
                  ))}
                </div>
                <Button
                  size="sm"
                  variant="outline"
                  className="mt-2 border-slate-700 text-cyan-400 hover:bg-slate-800"
                  onClick={() => document.getElementById('photo-input').click()}
                >
                  <ImageIcon className="w-4 h-4 mr-2" />
                  Adicionar Fotos
                </Button>
              </div>
              <div className="flex gap-2">
                <Button onClick={handleSaveEdit} className="flex-1 bg-cyan-500 hover:bg-cyan-600">
                  <Save className="w-4 h-4 mr-2" />
                  Salvar
                </Button>
                <Button onClick={handleDeleteMarker} variant="destructive" className="flex-1">
                  <Trash2 className="w-4 h-4 mr-2" />
                  Deletar
                </Button>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Dialog de adicionar marcação */}
      <Dialog open={showAddMarkerDialog} onOpenChange={setShowAddMarkerDialog}>
        <DialogContent className="bg-slate-900 text-white border-slate-700 max-w-md">
          <DialogHeader>
            <DialogTitle className="text-cyan-400">Adicionar Marcação</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <Label className="text-gray-300">Nome *</Label>
              <Input
                value={newMarkerData.name}
                onChange={(e) => setNewMarkerData({ ...newMarkerData, name: e.target.value })}
                className="bg-slate-800 border-slate-700 text-white"
                placeholder="Nome da marcação"
              />
            </div>
            <div className="grid grid-cols-2 gap-2">
              <div>
                <Label className="text-gray-300">Latitude *</Label>
                <Input
                  value={newMarkerData.lat}
                  onChange={(e) => setNewMarkerData({ ...newMarkerData, lat: e.target.value })}
                  className="bg-slate-800 border-slate-700 text-white"
                  placeholder="-9.6658"
                  type="number"
                  step="any"
                />
              </div>
              <div>
                <Label className="text-gray-300">Longitude *</Label>
                <Input
                  value={newMarkerData.lng}
                  onChange={(e) => setNewMarkerData({ ...newMarkerData, lng: e.target.value })}
                  className="bg-slate-800 border-slate-700 text-white"
                  placeholder="-35.7353"
                  type="number"
                  step="any"
                />
              </div>
            </div>
            <div>
              <Label className="text-gray-300">Bairro</Label>
              <Select
                value={newMarkerData.bairro}
                onValueChange={(value) => setNewMarkerData({ ...newMarkerData, bairro: value })}
              >
                <SelectTrigger className="bg-slate-800 border-slate-700 text-white">
                  <SelectValue placeholder="Selecione um bairro" />
                </SelectTrigger>
                <SelectContent className="bg-slate-800 border-slate-700 text-white z-[9999]">
                  {bairros.map(bairro => (
                    <SelectItem key={bairro} value={bairro}>{bairro}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div>
              <Label className="text-gray-300">Descrição</Label>
              <Textarea
                value={newMarkerData.descricao}
                onChange={(e) => setNewMarkerData({ ...newMarkerData, descricao: e.target.value })}
                className="bg-slate-800 border-slate-700 text-white"
                rows={3}
              />
            </div>
            <Button onClick={handleAddMarker} className="w-full bg-cyan-500 hover:bg-cyan-600">
              <Plus className="w-4 h-4 mr-2" />
              Adicionar
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Dialog de cálculo de rota personalizada */}
      <Dialog open={showRouteDialog} onOpenChange={setShowRouteDialog}>
        <DialogContent className="bg-slate-900 text-white border-slate-700 max-w-md">
          <DialogHeader>
            <DialogTitle className="text-cyan-400">Calcular Rota Personalizada</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <p className="text-gray-300">Selecione os marcadores para calcular a rota. Você pode selecionar até 2 marcadores.</p>
            <div className="max-h-60 overflow-y-auto pr-2">
              {filteredMarkers.map(marker => (
                <div
                  key={marker.id}
                  className={`flex items-center justify-between p-2 rounded-md cursor-pointer mb-2
                    ${selectedMarkersForRoute.some(m => m.id === marker.id) ? 'bg-cyan-700/30' : 'bg-slate-800/50 hover:bg-slate-800'}`}
                  onClick={() => {
                    if (selectedMarkersForRoute.some(m => m.id === marker.id)) {
                      setSelectedMarkersForRoute(prev => prev.filter(m => m.id !== marker.id))
                    } else if (selectedMarkersForRoute.length < 2) {
                      setSelectedMarkersForRoute(prev => [...prev, marker])
                    } else {
                      alert('Você já selecionou 2 marcadores. Desmarque um para selecionar outro.')
                    }
                  }}
                >
                  <div className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={selectedMarkersForRoute.some(m => m.id === marker.id)}
                      readOnly
                      className="form-checkbox h-4 w-4 text-cyan-600 bg-slate-700 border-slate-600 rounded focus:ring-cyan-500"
                    />
                    <span className="text-white">{marker.name}</span>
                  </div>
                  {marker.bairro && <span className="text-xs text-gray-400">{marker.bairro}</span>}
                </div>
              ))}
            </div>
            <div className="flex gap-2 mt-4">
              <Button
                onClick={async () => {
                  if (selectedMarkersForRoute.length === 2) {
                    setCalculatingRoute(true)
                    const [m1, m2] = selectedMarkersForRoute
                    const route = await getRouteFromAPI([m1.lng, m1.lat], [m2.lng, m2.lat])

                    if (route) {
                      setRouteCoordinates(route)
                      const coordinates = [
                        [m1.lng, m1.lat],
                        [m2.lng, m2.lat]
                      ]
                      const distanceMatrix = await calculateDistanceMatrix(coordinates)
                      let distance

                      if (distanceMatrix && distanceMatrix[0] && distanceMatrix[0][1]) {
                        distance = distanceMatrix[0][1]
                      } else {
                        distance = calculateDistance(m1.lat, m1.lng, m2.lat, m2.lng)
                      }

                      setDistanceResult({
                        type: 'dois',
                        distance: distance.toFixed(2),
                        markers: [m1.name, m2.name],
                        method: 'rota'
                      })
                    } else {
                      const distance = calculateDistance(m1.lat, m1.lng, m2.lat, m2.lng)
                      setRouteCoordinates([[m1.lat, m1.lng], [m2.lat, m2.lng]])
                      setDistanceResult({
                        type: 'dois',
                        distance: distance.toFixed(2),
                        markers: [m1.name, m2.name],
                        method: 'linha reta'
                      })
                    }
                    setCalculatingRoute(false)
                    setShowRouteDialog(false)
                    setSelectedMarkersForRoute([])
                    setSidebarOpen(false)
                  } else {
                    alert('Selecione exatamente 2 marcadores para calcular a rota.')
                  }
                }}
                className="flex-1 bg-cyan-500 hover:bg-cyan-600"
                disabled={selectedMarkersForRoute.length !== 2 || calculatingRoute}
              >
                <Navigation className="w-4 h-4 mr-2" />
                Calcular Rota
              </Button>
              <Button
                onClick={() => {
                  setShowRouteDialog(false)
                  setSelectedMarkersForRoute([])
                }}
                variant="outline"
                className="border-slate-700 text-gray-300 hover:bg-slate-800"
              >
                Cancelar
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>



      {/* Input oculto para upload de arquivo */}
      <input
        id="file-input"
        type="file"
        accept=".kml,.kmz"
        onChange={handleFileImport}
        className="hidden"
      />

      {/* Input oculto para upload de fotos */}
      <input
        id="photo-input"
        type="file"
        accept="image/*"
        multiple
        onChange={handlePhotoUpload}
        className="hidden"
      />
    </div>
  )
}

export default App

